'''
Functions for Ois 200 Data Processing.
After these process, we can transfer data into standard processing matrix.

Both matlab and Python Style Contained.(I wish)



########################## LOGS ###############################
(Actually you can do this on git = =)

ver 0.0.1 by ZR, function created. 2024/04/18


'''

#%% Basic Imports

import os
import struct
import numpy as np 



#%% F1 single ai bin file reader.

def Analog_Bin_Reader_Core(filename):

    """
    Read single analog bin file in Ois 200 system.
    Following lines might seems to be non-sense, if You have problem, check in the manual.

    Parameters
    ----------
    filename : (str)
        Name of single bin file.


    Returns
    -------
    header_info : (1D np array)
       Headfile info, in format [version,N_channels,Capture_Rate,Max_Capture_Rate,Max_Capture_Seconds]

    all_channel_ai_signals: (12D np array)
        Data of all channels array.
       
    """
    with open(filename, mode='rb') as file: # b is important -> binary
        header_bytes = file.read(20) # in Ois system, the first 5 4bit are header info
        data_bytes = file.read()
    # read header
    header = struct.unpack('5i', header_bytes) # headers are int format(i)
    # print(f"Number of analog channels : {header[1]}")

    # unpack data. The data are written in double d format.
    data = struct.unpack(f'{len(data_bytes)//8}d', data_bytes) # data are recorded in float64, so 8 bit in 1 unit.
    data_matrix = np.array(data)
    cycle_num = len(data_matrix)//120000
    all_channel_ai_signals = np.zeros(shape = (cycle_num*10000,12))
    for i in range(cycle_num):
        c_cuts = data_matrix[i*120000:(i+1)*120000]
        c_ai_signals = np.reshape(c_cuts,(12,-1))
        all_channel_ai_signals[i*10000:(i+1)*10000,:] = c_ai_signals.T
    
    header_info = np.array(header)

    return header_info,all_channel_ai_signals

#%% F2 Read all bin files.
def Analog_Reader_All(analog_file_names,mute = False):

    """
    Read single analog bin file in Ois 200 system.
    Following lines might seems to be non-sense, if You have problem, check in the manual.

    Parameters
    ----------
    analog_file_names : (list)
        List of all analog file, this usually generated by function.
    mute : (bool),optional
        If mute == False, info will be shown.

    Returns
    -------
    header_info : (1D np array)
       Headfile info, in format [version,N_channels,Capture_Rate,Max_Capture_Rate,Max_Capture_Seconds]

    all_signals: (12D np array)
        Data of all channels array. Ch 1 is Camera trigger, 
       
    """
    # just put all series together.
    for i,c_analog_name in enumerate(analog_file_names):
        head_info,c_singal_part = Analog_Bin_Reader_Core(c_analog_name)
        if i == 0:
            all_signals = c_singal_part
        else:
            all_signals = np.concatenate((all_signals,c_singal_part))
    
    if mute == False:
        print(f'Channel Num:{head_info[1]}, fps :{head_info[2]} Hz.')
        all_time = len(all_signals)/head_info[2]
        print(f'Series Capture Time: {all_time:.1f}s')
    
    return head_info,all_signals
#%% F3 Read single bin image files.
def Graph_Bin_Reader_Core(filename):
    '''
    Read single graph bin file in Ois 200 system.
    Following lines might seems to be non-sense, if You have problem, check in the manual.

    Parameters
    ----------
    filename : (str)
        Name of single bin file.

    Returns
    -------
    header_info : (1D np array)
       Headfile info, in format [version,X dim,Y dim,img size in byte,max frame num per bin.]

    graph_matrix: (np array)
        Data of all graph array.
       
    '''
    with open(filename, mode='rb') as file: # b is important -> binary
        header_bytes = file.read(20) # in Ois system, the first 5 4bit are header info
        data_bytes = file.read()
    # read header
    header = struct.unpack('5i', header_bytes) # headers are int format(i)
    header_info = np.array(header)

    # unpack data. For each frame, it have 3 int64 headers.
    total_framenum = len(data_bytes)//header_info[3]
    x_width = header_info[1]
    y_width = header_info[2]

    all_frames = np.zeros(shape = (total_framenum,x_width,y_width),dtype='u2')

    for i in range(total_framenum):
        c_graph_bytes = data_bytes[i*header_info[3]:(i+1)*header_info[3]]
        # get each graph head, having it's [index,missed trigger,camera clc.]
        c_graph_head = np.array(struct.unpack(f'3q', c_graph_bytes[:24])) # data are recorded in int64, so 8 bit in 1 unit.
        img_data = np.array(struct.unpack(f'{x_width*y_width}H',c_graph_bytes[24:]))
        all_frames[i,:,:] = img_data.reshape((x_width,y_width))
    
    return header_info,all_frames

#%% F4 Read all bin image files.
def Graph_Reader_All(img_file_lists,channel_names = ['Red'],mute = False):
    """
    Read All Graph bins together, return img stacks of each channel. 

    Parameters
    ----------
    img_file_lists : (list)
        List of all img bin file, this usually generated by function.

    channel_num : (int)
        Number of channels in capturing. This must be sure!

    mute : (bool),optional 
        If mute == False, info will be shown.


    Returns
    -------
    header_info : (1D np array)
       Headfile info, in format [version,N_channels,Capture_Rate,Max_Capture_Rate,Max_Capture_Seconds]

    all_graphs_channel: (dictionary)
        dictionary of all img files.
       
    """
    channel_num = len(channel_names)
    for i,c_img_name in enumerate(img_file_lists):
        head_info,c_frame = Graph_Bin_Reader_Core(c_img_name)
        if i == 0:
            all_graphs = c_frame
        else:
            all_graphs = np.concatenate((all_graphs,c_frame),axis = 0)
    if mute == False:
        print(f'Graph Resolution: {head_info[1]} x {head_info[2]} .')
        print(f'Graph Number: {all_graphs.shape[0]}, in {channel_num} channels.')

    # cut all graphs into different channels, and save them as a dic.
    common_num = len(all_graphs)//channel_num # ignore last few frames in complete.
    all_graphs_channel = {}
    for i,c_channel in enumerate(channel_names):
        all_graphs_channel[c_channel] = np.zeros(shape=(common_num,head_info[1],head_info[2]),dtype='u2')
    for i in range(common_num*channel_num):
        all_graphs_channel[channel_names[i%channel_num]][i//channel_num,:,:] = all_graphs[i,:,:]

    return head_info,all_graphs_channel
    
#%% F5 info reader
def Info_Reader(txt_path):
    # read in txt 
    info_dics = {}
    info_file = open(txt_path, "r")
    info_data = info_file.read().split('\n')
    # get capture frequency.
    capture_freq = list(filter(lambda x: 'FrameRateHz' in x, info_data))[0]
    capture_freq = float(capture_freq.split(':')[-1])
    # get img channel numbers.
    img_channels = list(filter(lambda x: 'Illumination' in x, info_data))
    img_channels = list(map(lambda x: x.split(':')[-1].strip(), img_channels))


    # save element into dics.
    info_dics['Imaging_Freq'] = capture_freq
    info_dics['Channel_Names'] = img_channels
    return info_dics




#%% Total  class of Data Procesing.


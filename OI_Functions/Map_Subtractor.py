'''

This class will do basic map subtraction or ttest on given conditions.
Mask, Clip, Filter can be added easily using class method.



####################### Logs #####################
ver 0.0.1  2024/04/25 Class Generated by ZR



'''
#%%
import numpy as np
import Common_Functions as cf
import matplotlib.pyplot as plt
import scipy.stats as stats
import seaborn as sns
import pandas as pd
from scipy.ndimage import gaussian_filter

class Sub_Map_Generator(object):
    name = r'Generat subtraction and t maps.'
    def __init__(self,dRR_dics) -> None:
        self.dRR_dics = dRR_dics
        print(f'All Condition ID Names:{self.dRR_dics.keys()}')

    def Submap_Core(self,cond_A,cond_B,used_frame = np.arange(4,16),map = 'ttest'): 
        '''This function wil draw unmasked raw t or dff map on given conditions.
        Parameters
        ----------
        cond_A : (list)
            List of A condition names.
        cond_B : (list)
            List of B condition names,we will calculate A-B.
        used_frame : (list),optional.
            List of used frames to calculate response dR/R. The default is frame 4-16
        map : ('ttest' or 'sub')
            In which method we calculate submaps.

        Returns
        -------
        dRR_map : (2D np array)
            Raw data of calculated subgraph, just raw data with no process.
        p_values : (2D np array)
            P values of ttest data. Will return an all-0 matrix if use subtraction mathod only.
        
        '''
        for i,c_cond in enumerate(cond_A):
            if i == 0:
                A_conds = self.dRR_dics[c_cond]
            else:
                A_conds = np.concatenate((A_conds,self.dRR_dics[c_cond]))
        for i,c_cond in enumerate(cond_B):
            if i == 0:
                B_conds = self.dRR_dics[c_cond]
            else:
                B_conds = np.concatenate((B_conds,self.dRR_dics[c_cond])) 
        used_A_frames = A_conds[:,used_frame,:,:].reshape((-1,A_conds.shape[2],A_conds.shape[3]))
        used_B_frames = B_conds[:,used_frame,:,:].reshape((-1,B_conds.shape[2],B_conds.shape[3]))

        if map == 'sub':
            dRR_map = used_A_frames.mean(0)-used_B_frames.mean(0)
            p_values = np.ones(shape = (B_conds.shape[2],B_conds.shape[3]))
        elif map == 'ttest':
            dRR_map,p_values = stats.ttest_ind(used_A_frames,used_B_frames,axis = 0)
            dRR_map = np.nan_to_num(dRR_map,nan = 0)
        return dRR_map,p_values
    
    def Get_Map(self,cond_A,cond_B,
                clip_method = 'std',clip_value = 2,
                used_frame = np.arange(4,16),
                map = 'ttest',
                save_flag = True,savepath = r'Results',graph_name = 'Test',
                filter_flag = True,LP_sigma = 0.75,HP_sigma = 300
                ):
        '''
        This function will get subtraction map and do clip, Then visualize submap,and save on given folder.

        We need to add a filter afterward.

        Parameters
        ----------
        cond_A,cond_B,used_frame,map parameters are transfered into self.Submap_Core.

        clip_method : ('std' or 'fix')
            Will use clip_value*std as clip if you chooose std, else if you choose fix, clip will use a fixed value.
        save_flag : (bool)
            Whether we save generated graph. Both graph and raw data will be saved.
        save_path : (str)
            Path to save sub graph.
        graph_name : (str)
            Name of saved graph.
        filter_flag : (bool)
            Whether we do filter on graph.

        '''
        raw_drr,p_values = self.Submap_Core(cond_A,cond_B,used_frame,map)

        # clip and normalize graph.
        if clip_method == 'std': # clip result on std
            clipped_graph = np.clip(raw_drr,raw_drr.mean()-clip_value*raw_drr.std(),raw_drr.mean()+clip_value*raw_drr.std())
        elif clip_method == 'fix':
            clipped_graph = np.clip(raw_drr,raw_drr.mean()-clip_value,raw_drr.mean()+clip_value)

        # filter and normalize.
        if filter_flag:
            HP_graph = gaussian_filter(input = clipped_graph, sigma = HP_sigma)
            LP_graph = gaussian_filter(input = clipped_graph, sigma = LP_sigma)
            filted_graph = (LP_graph-HP_graph)

        # normed_graph = filted_graph/max(abs(filted_graph.min()),filted_graph.max())
        # graph = (normed_graph+1)*32767
        normed_graph = (filted_graph-filted_graph.min())/(filted_graph.max()-filted_graph.min())
        graph = normed_graph*65535
        plt.imshow(graph, cmap='gray', vmin=0, vmax=65535)
        if save_flag == True:
            cf.mkdir(savepath)
            whole_path = cf.join(savepath,f'{graph_name}.png')
            plt.imsave(whole_path,graph, cmap='gray', vmin=0, vmax=65535)
            cf.Save_Variable(savepath,f'{graph_name}_Raw',raw_drr)
            cf.Save_Variable(savepath,f'{graph_name}_p_value',p_values)

        return graph,raw_drr,p_values

    def Condition_Response_Curve(self,mask = []):
    # generate response curve of all frames and plot in subplots.
        all_conditions = list(self.dRR_dics.keys())
        all_conditions.remove(-1)
        self.Response_Curves = pd.DataFrame(columns = ['ID','Frame','Response'])
        if len(mask) == 0:
            print(f'No Mask Used.')
            mask = np.ones(shape = (self.dRR_dics[-1].shape[1],self.dRR_dics[-1].shape[2]))
            
        for i,c_id in enumerate(all_conditions):
            c_drr = self.dRR_dics[c_id]
            c_drr = c_drr*mask
            masked_drr = np.sum(c_drr,axis=(-2, -1))/mask.sum()
            for j in range(len(masked_drr)):
                for k in range(masked_drr.shape[1]):
                    self.Response_Curves.loc[len(self.Response_Curves),:] = [c_id,k,masked_drr[j,k]]
        print('dR/R Curves Done.')



if __name__ == '__main__':
    
    wp = r'D:\ZR\_Data_Temp\Ois200_Data\240417_M3_Bars\test_exposetime0.1ms_Vbar_Run01\Preprocessed'
    dRR_dics = cf.Load_Variable(wp,'dRR_Dictionaries.pkl')
    all_conditions = list(dRR_dics.keys())
    cond_A = [1287.9, 1001.7]
    cond_B = [715.5, 429.3, 143.1]
    calculator = Sub_Map_Generator(dRR_dics)
    c_submap,_ = calculator.Submap_Core([429.3],[143.1])
    plt.imshow(np.clip(c_submap,0,5))
    calculator.Condition_Response_Curve()
    a = calculator.Response_Curves